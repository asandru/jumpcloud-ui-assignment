import React, { useState } from 'react'
import Grid from '@material-ui/core/Grid'
import Card from '@material-ui/core/Card'
import CardContent from '@material-ui/core/CardContent'
import CardActions from '@material-ui/core/CardActions'
import TextField from '@material-ui/core/TextField'
import Button from '@material-ui/core/Button'

import { useStyles } from '../../styles/UserDetailsCard_styles'
import { USER_MIDDLENAME_COLUMN_ID, USER_DISPLAYNAME_COLUMN_ID, USER_LASTNAME_COLUMN_ID, USER_FIRSTNAME_COLUMN_ID,
  USER_USERNAME_COLUMN_ID, USER_EMAIL_COLUMN_ID} from '../tables/gridMetadata'

export default function UserDetailsCard(
    {  user = {}, 
       onUserSave = f => f, 
       onUserCancel = f => f}
    ) {

    const classes = useStyles()
    const [errors, setErrors] = useState({}) // assume no error, to start with ...

    // In this object, only specify the fields that we plan to allow user to modify.
    // id field cannot be among them because the id value is generated by the server, when we send a POST request
    // and it cannot be modified afterwards anyways.

    // All the TextFields in this component need to be controlled components
    // (i.e. their 'value' property to be mapped to values in this React state)
    // That's because beside user typing manually, these fields need to be programatically updated when
    // the user prop changes (i.e. for the case when we need to display an empty form)
    const [lastname, setLastname] = useState((user.lastname || ''))
    const [middlename, setMiddlename] = useState((user.middlename || ''))
    const [firstname, setFirstname] = useState((user.firstname || ''))
    const [username, setUsername] = useState((user.username || ''))
    const [displayname, setDisplayname] = useState((user.displayname || ''))
    const [email, setEmail] = useState((user.email || ''))

    const [dirtyForm, setDirtyForm] = useState(false)

    // Given a text field name, this function determines if there are errors for this particular text field
    const hasError = (name) => {
        if (errors[name]) {
            return true
        }
        return false
    }

    const hasAnyErrors = () => {
      return (Object.keys(errors).length > 0)
    }

    const isNewUser = () => {
      return (Object.keys(user).length === 0)
    }

    const onSubmit = () => { 
      // Do validation before submision
      // This is needed when user wants to start with a blank form but then hits Save button.
      if (!username) {
        setErrors({...errors, username: 'Username cannot be empty'}) // show error for that particular text field
        return // validation failed. don't allow change 
      }
      if (!email) {
        setErrors({...errors, email: 'This email cannot be empty'}) // show error for that particular text field
        return // validation failed. don't allow change 
      } 

      // Return all data to parent component, by first overwriting the original data with the modified data.
      let updatedUser = {lastname, firstname, middlename, username, email, displayname}

      // If we have a user id (as part of original props), it means we're using this form to update an existing user
      // as opposed to creating a new one. So include that in the final result because it will be used
      // when triggering a PUT request
      if (user.id) {
        updatedUser.id = user.id
    }
      onUserSave(updatedUser, isNewUser())
    }

    const onFirstNameChanged = (event) => {
      //console.log('Value is now: ' + event.target.value)
      // No validation on this field
      setDirtyForm(true)
      setFirstname(event.target.value)
    }

    const onMiddleNameChanged = (event) => {
      //console.log('Value is now: ' + event.target.value)
      // No validation on this field
      setDirtyForm(true)
      setMiddlename(event.target.value)
    }  

    const onLastNameChanged = (event) => {
      //console.log('Value is now: ' + event.target.value)
      // No validation on this field
      setDirtyForm(true)
      setLastname(event.target.value)
    }

    const onUsernameChanged = (event) => {
      //console.log('Value is now: ' + event.target.value)
      setUsername(event.target.value)
      setDirtyForm(true)

      // Validation on this field: username cannot be blank
      if (!event.target.value) {
        setErrors({...errors, username: 'Username cannot be empty'})
        return
      }
  
      // User entered at least one char, so clear any previous error related to this field.
      if (errors.username) {
        let tmp = {...errors}
        delete tmp[USER_USERNAME_COLUMN_ID]
        setErrors(tmp)
      }
    }

    const onDisplayNameChanged = (event) => {
      //console.log('Value is now: ' + event.target.value)
      // No validation on this field
      setDirtyForm(true)
      setDisplayname(event.target.value)
    }

    const onEmailChanged = (event) => {
        console.log('Value is now: ' + event.target.value)
        setDirtyForm(true)
        setEmail(event.target.value)

        // Validation on this field: company email cannot be blank
        if (!event.target.value) {
          setErrors({...errors, email: 'This email cannot be empty'})
          return
        } 
        if (!event.target.value.includes('@')) {
          setErrors({...errors, email: 'Email must be of the form <user>@<domain>.com'})
          return
        }
  
        // User entered at least one char, so clear any previous error related to this field.
        if (errors.email) {
          let tmp = {...errors}
          delete tmp[USER_EMAIL_COLUMN_ID]
          setErrors(tmp)
        }
    }

    const disableSaveButton = hasAnyErrors()
    if (Object.keys(user).length === 0) {
      if (!dirtyForm &&
       (lastname || firstname || middlename || username || displayname|| email)) {
         // Properties to this component have changed, so update the React state
         // which in turn will automatically trigger an update which will upadte the 'value' props on all TextFields
         console.log('Detected a change in input props to this component')
         setLastname('')
         setFirstname('')
         setMiddlename('')
         setDisplayname('')
         setUsername('')
         setEmail('')
       }
    } else { // called when you browser between users, clicking on edit icon of each user
       // only change the field that was affected..
       if (user.firstname !== firstname && !dirtyForm) {
        setFirstname(user.firstname)
       } 
       if (user.lastname !== lastname && !dirtyForm) {
        setLastname(user.lastname)
       }
       if (user.middlename !== middlename && !dirtyForm) {
        setMiddlename(user.middlename)
       }
       if (user.username !== username && !dirtyForm) {
        setUsername(user.username)
       }
       if(user.email !== email && !dirtyForm) {
        setEmail(user.email)
       }
       if (user.displayname !== displayname && !dirtyForm) {
        setDisplayname(user.displayname)
       }
    }


    return (
      <Card>
          <CardContent>
              <Grid container className={classes.rootContainer}>
                <Grid container className={classes.rowContainer}>
                    <TextField 
                      label='First Name'
                      className={classes.textField}
                      value={firstname}
                      helperText={errors.firstname}
                      error={hasError(USER_FIRSTNAME_COLUMN_ID)}
                      onChange={(event) => onFirstNameChanged(event)}
                    >
                    </TextField>

                    <TextField 
                      label='Middle Name' 
                      className={classes.textField}
                      value={middlename}
                      helperText={errors.middlename}
                      error={hasError(USER_MIDDLENAME_COLUMN_ID)}
                      onChange={(event) => onMiddleNameChanged(event)}
                    >
                    </TextField>

                    <TextField 
                      label='Last Name'
                      className={classes.textField}
                      value={lastname}
                      helperText={errors.lastname}
                      error={hasError(USER_LASTNAME_COLUMN_ID)}
                      onChange={(event) => onLastNameChanged(event)}
                    >
                    </TextField>
                </Grid>
                <Grid container className={classes.rowContainer}>
                    <TextField 
                      label='Username *'
                      className={classes.textField}
                      helperText={errors.username}
                      value={username}
                      error={hasError(USER_USERNAME_COLUMN_ID)}
                      onChange={(event) => onUsernameChanged(event)}
                    >
                    </TextField>
                    <TextField 
                      label='Display Name'
                      className={classes.textField}
                      value={displayname}
                      helperText={errors.displayname}
                      error={hasError(USER_DISPLAYNAME_COLUMN_ID)}
                      onChange={(event) => onDisplayNameChanged(event)}
                    >
                    </TextField>
                    <TextField 
                      label='Company Email *'
                      className={classes.textField}
                      value={email}
                      helperText={errors.email}
                      error={hasError(USER_EMAIL_COLUMN_ID)}
                      onChange={(event) => onEmailChanged(event)}
                    >
                    </TextField>
                </Grid>
              </Grid>
          </CardContent>

          <CardActions>
            <Button disabled={disableSaveButton} onClick={onSubmit}>Save</Button>
            <Button onClick={onUserCancel}>Cancel</Button>
          </CardActions>
      </Card>
    )
}